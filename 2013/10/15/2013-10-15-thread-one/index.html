<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="wxhao">
  <!-- Open Graph Data -->
  <meta property="og:title" content="多线程"/>
  <meta property="og:description" content="站点描述" />
  <meta property="og:site_name" content="标题"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://blog.wxhaoo.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="标题" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>标题</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">多线程</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/levblanc">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:levblanc@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By wxhao</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2013-10-15</span>
            <span class="time">17:38:06</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/基础知识/">#基础知识</a> <a class="tag" href="/tags/java/">#java</a> <a class="tag" href="/tags/JAVASE/">#JAVASE</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="多线程的引入"><a href="#多线程的引入" class="headerlink" title="多线程的引入"></a>多线程的引入</h3><ul>
<li>1.什么是线程<ul>
<li>线程是程序执行的一条路径, 一个进程中可以包含多条线程</li>
<li>多线程并发执行可以提高程序的效率, 可以同时完成多项工作</li>
</ul>
</li>
<li>2.多线程的应用场景<ul>
<li>红蜘蛛同时共享屏幕给多个电脑</li>
<li>迅雷开启多条线程一起下载</li>
<li>QQ同时和多个人一起视频</li>
<li>服务器同时处理多个客户端请求</li>
</ul>
</li>
</ul>
<h3 id="多线程并行和并发的区别"><a href="#多线程并行和并发的区别" class="headerlink" title="多线程并行和并发的区别"></a>多线程并行和并发的区别</h3><ul>
<li>并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)</li>
<li>并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。</li>
<li>比如我跟两个网友聊天，左手操作一个电脑跟甲聊，同时右手用另一台电脑跟乙聊天，这就叫并行。</li>
<li>如果用一台电脑我先给甲发个消息，然后立刻再给乙发消息，然后再跟甲聊，再跟乙聊。这就叫并发。</li>
</ul>
<h3 id="Java程序运行原理和JVM的启动是多线程的吗"><a href="#Java程序运行原理和JVM的启动是多线程的吗" class="headerlink" title="Java程序运行原理和JVM的启动是多线程的吗"></a>Java程序运行原理和JVM的启动是多线程的吗</h3><ul>
<li><p>A:Java程序运行原理</p>
<ul>
<li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。</li>
</ul>
</li>
<li><p>B:JVM的启动是多线程的吗</p>
<ul>
<li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * 证明jvm是多线程的</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		for(int i = 0; i &lt; 100000; i++) &#123;</div><div class="line">			new Demo();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		for(int i = 0; i &lt; 10000; i++) &#123;</div><div class="line">			System.out.println(&quot;我是主线程的执行代码&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Demo &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void finalize() &#123;</div><div class="line">		System.out.println(&quot;垃圾被清扫了&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多线程程序实现的方式1"><a href="#多线程程序实现的方式1" class="headerlink" title="多线程程序实现的方式1"></a>多线程程序实现的方式1</h3><ul>
<li>1.继承Thread<ul>
<li>定义类继承Thread</li>
<li>重写run方法</li>
<li>把新线程要做的事写在run方法中</li>
<li>创建线程对象</li>
<li>开启新线程, 内部会自动执行run方法</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Demo2_Thread &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MyThread mt = new MyThread();		//4,创建Thread类的子类对象</div><div class="line">		mt.start();							//5,开启线程</div><div class="line">		</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;</div><div class="line">			System.out.println(&quot;bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread &#123;				//1,继承Thread</div><div class="line">	public void run() &#123;						//2,重写run方法</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;		//3,将要执行的代码写在run方法中</div><div class="line">			System.out.println(&quot;aaaaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多线程程序实现的方式2"><a href="#多线程程序实现的方式2" class="headerlink" title="多线程程序实现的方式2"></a>多线程程序实现的方式2</h3><ul>
<li>2.实现Runnable<ul>
<li>定义类实现Runnable接口</li>
<li>实现run方法</li>
<li>把新线程要做的事写在run方法中</li>
<li>创建自定义的Runnable的子类对象</li>
<li>创建Thread对象, 传入Runnable</li>
<li>调用start()开启新线程, 内部会自动调用Runnable的run()方法</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Demo3_Thread &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MyRunnable mr = new MyRunnable();	//4,创建Runnable的子类对象</div><div class="line">		//Runnable target = mr;	mr = 0x0011</div><div class="line">		Thread t = new Thread(mr);			//5,将其当作参数传递给Thread的构造函数</div><div class="line">		t.start();							//6,开启线程</div><div class="line">		</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;			</div><div class="line">		System.out.println(&quot;bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyRunnable implements Runnable &#123;		//1,定义一个类实现Runnable</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void run() &#123;						//2,重写run方法</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;		//3,将要执行的代码写在run方法中</div><div class="line">			System.out.println(&quot;aaaaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现Runnable的原理"><a href="#实现Runnable的原理" class="headerlink" title="实现Runnable的原理"></a>实现Runnable的原理</h3><ul>
<li>查看源码<ul>
<li>1,看Thread类的构造函数,传递了Runnable接口的引用 </li>
<li>2,通过init()方法找到传递的target给成员变量的target赋值</li>
<li>3,查看run方法,发现run方法中有判断,如果target不为null就会调用Runnable接口子类对象的run方法</li>
</ul>
</li>
</ul>
<h3 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h3><ul>
<li><p>查看源码的区别:</p>
<ul>
<li>a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法</li>
<li>b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法</li>
</ul>
</li>
<li><p>继承Thread</p>
<ul>
<li>好处是:可以直接使用Thread类中的方法,代码简单</li>
<li>弊端是:如果已经有了父类,就不能用这种方法</li>
</ul>
</li>
<li>实现Runnable接口<ul>
<li>好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的</li>
<li>弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂</li>
</ul>
</li>
</ul>
<h3 id="匿名内部类实现线程的两种方式"><a href="#匿名内部类实现线程的两种方式" class="headerlink" title="匿名内部类实现线程的两种方式"></a>匿名内部类实现线程的两种方式</h3><ul>
<li><p>继承Thread类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">new Thread() &#123;										//1,继承Thread类</div><div class="line">public void run() &#123;								//2,重写run方法</div><div class="line">	for(int i = 0; i &lt; 1000; i++) &#123;				//3,将要执行的代码写在run方法中</div><div class="line">		System.out.println(&quot;aaaaaaaaaaaaaa&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">&#125;.start();											//4,开启线程</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>实现Runnable接口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;							//1,将Runnable的子类对象传递给Thread的构造方法</div><div class="line">	public void run() &#123;								//2,重写run方法</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;				//3,将要执行的代码写在run方法中</div><div class="line">			System.out.println(&quot;bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();											//4,开启线程</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取名字和设置名字"><a href="#获取名字和设置名字" class="headerlink" title="获取名字和设置名字"></a>获取名字和设置名字</h3><ul>
<li>1.获取名字<ul>
<li>通过getName()方法获取线程对象的名字</li>
</ul>
</li>
<li>2.设置名字</li>
<li>通过构造函数可以传入String类型的名字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">new Thread(&quot;芙蓉姐姐&quot;) &#123;		//通过构造方法给name赋值</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(this.getName() + &quot;....aaaaaaaaa&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div><div class="line"></div><div class="line">new Thread(&quot;凤姐&quot;) &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(this.getName() + &quot;....bb&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div></pre></td></tr></table></figure>
<ul>
<li>通过setName(String)方法可以设置线程对象的名字<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Thread t1 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		//this.setName(&quot;张三&quot;);</div><div class="line">		System.out.println(this.getName() + &quot;....aaaaaaaaaaaaa&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread t2 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		//this.setName(&quot;李四&quot;);</div><div class="line">		System.out.println(this.getName() + &quot;....bb&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">t1.setName(&quot;张三&quot;);</div><div class="line">t2.setName(&quot;李四&quot;);</div><div class="line">t1.start();</div><div class="line">t2.start();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="获取当前线程的对象"><a href="#获取当前线程的对象" class="headerlink" title="获取当前线程的对象"></a>获取当前线程的对象</h3><ul>
<li>Thread.currentThread(), 主线程也可以获取</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;</div><div class="line">			System.out.println(Thread.currentThread().getName() + &quot;...aaaaaaaaaaaaaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 1000; i++) &#123;</div><div class="line">//Thread.currentThread()获取当前正在执行的线程			System.out.println(Thread.currentThread().getName() + &quot;...bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;).start();</div><div class="line">Thread.currentThread().setName(&quot;我是主线程&quot;);					//获取主函数线程的引用,并改名字</div><div class="line">System.out.println(Thread.currentThread().getName());		//获取主函数线程的引用,并获取名字</div></pre></td></tr></table></figure>
<h3 id="休眠线程"><a href="#休眠线程" class="headerlink" title="休眠线程"></a>休眠线程</h3><ul>
<li>Thread.sleep(毫秒,纳秒), 控制当前线程休眠若干毫秒1秒= 1000毫秒 1秒 = 1000 <em> 1000 </em> 1000纳秒 1000000000</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(int i = 20; i &gt;= 0; i--) &#123;</div><div class="line">	Thread.sleep(1000);</div><div class="line">	System.out.println(&quot;倒计时第&quot; +i + &quot;秒&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			try &#123; //父类没抛异常,子类必须自己处理</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(getName() + &quot;...aaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div><div class="line"></div><div class="line">new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			try &#123;</div><div class="line">				Thread.sleep(1000);</div><div class="line">			&#125; catch (InterruptedException e) &#123;</div><div class="line">				</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">			System.out.println(getName() + &quot;...bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li><p>setDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出</p>
</li>
<li><p>象棋举例,车马相士(守护线程),将帅(非守护线程)死后,其它的子也会死</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Thread t1 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 2; i++) &#123;</div><div class="line">			System.out.println(getName() + &quot;...aaaaaaaaaaaaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread t2 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 50; i++) &#123;</div><div class="line">			System.out.println(getName() + &quot;...bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">t2.setDaemon(true);		//设置为守护线程</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div></pre></td></tr></table></figure>
<ul>
<li><p>从输出结果可以看出,线程2并没有执行完,而是在线程1执行完后,就停止了</p>
</li>
<li><p>QQ主界面是非守护线程,传输窗口为守护线程,关闭QQ主界面,传输窗口也会随之退出,但不会立即退出,会有一个接受关闭命令的缓冲时间</p>
</li>
</ul>
<h3 id="加入线程"><a href="#加入线程" class="headerlink" title="加入线程"></a>加入线程</h3><ul>
<li>join(), 当前线程暂停, 等待指定的线程执行结束后, 当前线程再继续</li>
<li>相当于插队</li>
<li>join(int), 可以等待指定的毫秒之后继续</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">final Thread t1 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			System.out.println(getName() + &quot;...aaaaaaaaaaaaa&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread t2 = new Thread() &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			if(i == 2) &#123;</div><div class="line">				try &#123;</div><div class="line">					//匿名内部类调用的方法对象必须要用final 修饰</div><div class="line">					//t1.join();</div><div class="line">					t1.join(1);	//插队指定的时间,过了指定时间后,两条线程交替执行</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			System.out.println(getName() + &quot;...bb&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div></pre></td></tr></table></figure>
<h3 id="礼让线程"><a href="#礼让线程" class="headerlink" title="礼让线程"></a>礼让线程</h3><ul>
<li>yield让出cpu</li>
<li>实际效果不明显</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">	/**</div><div class="line">	 * yield让出cpu礼让线程</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new MyThread().start();</div><div class="line">		new MyThread().start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyThread extends Thread &#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 1; i &lt;= 1000; i++) &#123;</div><div class="line">			if(i % 10 == 0) &#123;</div><div class="line">				Thread.yield();						//让出CPU</div><div class="line">			&#125;</div><div class="line">			System.out.println(getName() + &quot;...&quot; + i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设置线程的优先级"><a href="#设置线程的优先级" class="headerlink" title="设置线程的优先级"></a>设置线程的优先级</h3><ul>
<li>setPriority()设置线程的优先级</li>
<li>效果不明显,看得出一点儿效果</li>
<li>优先级最大是10,最小是1,默认是5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Thread t1 = new Thread()&#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			System.out.println(getName() + &quot;...aaaaaaaaa&quot; );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Thread t2 = new Thread()&#123;</div><div class="line">	public void run() &#123;</div><div class="line">		for(int i = 0; i &lt; 100; i++) &#123;</div><div class="line">			System.out.println(getName() + &quot;...bb&quot; );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//t1.setPriority(10);	设置最大优先级</div><div class="line">//t2.setPriority(1);</div><div class="line"></div><div class="line">t1.setPriority(Thread.MIN_PRIORITY);//设置最小的线程优先级</div><div class="line">t2.setPriority(Thread.MAX_PRIORITY);//设置最大的线程优先级</div><div class="line"></div><div class="line">t1.start();</div><div class="line">t2.start();</div></pre></td></tr></table></figure>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><ul>
<li>1.什么情况下需要同步<ul>
<li>当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.</li>
<li>如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码.</li>
</ul>
</li>
<li>2.同步代码块<ul>
<li>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</li>
<li>多个同步代码块如果使用相同的锁对象, 那么他们就是同步的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		//匿名内部调用类局部变量 要用final修饰</div><div class="line">		final Printer p = new Printer();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					p.print1();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					p.print2();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Printer &#123;</div><div class="line">	Demo d = new Demo();</div><div class="line">	public void print1() &#123;</div><div class="line">		//synchronized(new Demo()) &#123;//同步代码块,锁机制,锁对象可以是任意的</div><div class="line">		synchronized(d) &#123;//为了保证输出的字符连成一句话,所以要让方法执行完前不执行另一个方法</div><div class="line">			System.out.print(&quot;我&quot;);</div><div class="line">			System.out.print(&quot;是&quot;);</div><div class="line">			System.out.print(&quot;大&quot;);</div><div class="line">			System.out.print(&quot;帅&quot;);</div><div class="line">			System.out.print(&quot;哔&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print2() &#123;</div><div class="line">		//synchronized(new Demo()) &#123;//锁对象不能用匿名对象,因为匿名对象不是同一个对象</div><div class="line">		synchronized(d) &#123;		</div><div class="line">			System.out.print(&quot;吴&quot;);</div><div class="line">			System.out.print(&quot;酷&quot;);</div><div class="line">			System.out.print(&quot;浩&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Demo&#123;&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以先屏蔽锁的代码,查看输出内容发现,会有问题一行字可能会多字,可能会少字</li>
<li>锁就相当于门,一个人进厕所关了门,另一个人是进不去的,要等这个人结束才能进去</li>
<li>锁可以是任意同一个对象</li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul>
<li><p>使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的</p>
</li>
<li><p>非静态的同步方法的锁对象是神马?</p>
<ul>
<li>非静态的同步方法的锁对象是this</li>
</ul>
</li>
<li>静态的同步方法的锁对象是什么?<ul>
<li>是该类的字节码对象</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Demo2_Synchronized &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @param args</div><div class="line">	 * 同步代码块</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Printer2 p = new Printer2();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					p.print1();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					p.print2();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Printer2 &#123;</div><div class="line">	Demo d = new Demo();</div><div class="line">	</div><div class="line">	public static synchronized void print1() &#123;	//同步方法只需要在方法上加synchronized关键字即可</div><div class="line">		System.out.print(&quot;我&quot;);</div><div class="line">		System.out.print(&quot;是&quot;);</div><div class="line">		System.out.print(&quot;大&quot;);</div><div class="line">		System.out.print(&quot;帅&quot;);</div><div class="line">		System.out.print(&quot;哔&quot;);</div><div class="line">		System.out.print(&quot;\r\n&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void print2() &#123;</div><div class="line">		//synchronized(new Demo()) &#123;	//锁对象不能用匿名对象,因为匿名对象不是同一个对象</div><div class="line">		synchronized(Printer2.class) &#123;		</div><div class="line">			System.out.print(&quot;吴&quot;);</div><div class="line">			System.out.print(&quot;嘉&quot;);</div><div class="line">			System.out.print(&quot;图&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ul>
<li>多线程并发操作同一数据时, 就有可能出现线程安全问题</li>
<li><p>使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作</p>
</li>
<li><p>需求:铁路售票,一共100张,通过四个窗口卖完.        </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">public class Demo3_Ticket &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 需求:铁路售票,一共100张,通过四个窗口卖完.</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Ticket().start();</div><div class="line">		new Ticket().start();</div><div class="line">		new Ticket().start();</div><div class="line">		new Ticket().start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Ticket extends Thread &#123;</div><div class="line">	private static int ticket = 100;</div><div class="line">	//private static Object obj = new Object();	//如果用引用数据类型成员变量当作锁对象,必须是静态的</div><div class="line">	public void run() &#123;</div><div class="line">		while(true) &#123;</div><div class="line">			synchronized(Ticket.class) &#123;</div><div class="line">				if(ticket &lt;= 0) &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				try &#123;</div><div class="line">					Thread.sleep(10);	//线程1睡,线程2睡,线程3睡,线程4睡</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(getName() + &quot;...这是第&quot; + ticket-- + &quot;号票&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>相同类的不同对象调用同一个方法使用共同值时会有问题,所以要用锁,不同对象要锁一个静态的对象,才能同步</li>
</ul>
<h3 id="火车站卖票的例子用实现Runnable接口"><a href="#火车站卖票的例子用实现Runnable接口" class="headerlink" title="火车站卖票的例子用实现Runnable接口"></a>火车站卖票的例子用实现Runnable接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Demo4_Ticket &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 火车站卖票的例子用实现Runnable接口</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		MyTicket mt = new MyTicket();</div><div class="line">		new Thread(mt).start();</div><div class="line">		new Thread(mt).start();</div><div class="line">		new Thread(mt).start();</div><div class="line">		new Thread(mt).start();</div><div class="line">		</div><div class="line">		/*Thread t1 = new Thread(mt);	//多次启动一个线程是非法的</div><div class="line">		t1.start();</div><div class="line">		t1.start();</div><div class="line">		t1.start();</div><div class="line">		t1.start();*/</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyTicket implements Runnable &#123;</div><div class="line">	private int tickets = 100;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		while(true) &#123;</div><div class="line">			synchronized(this) &#123;</div><div class="line">				if(tickets &lt;= 0) &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">				try &#123;</div><div class="line">					Thread.sleep(10);				//线程1睡,线程2睡,线程3睡,线程4睡</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.out.println(Thread.currentThread().getName() + &quot;...这是第&quot; + tickets-- + &quot;号票&quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现了Runnable接口,所以开启多线程时可以用一个对象,对象锁使用this就可以同步</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li>多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁<ul>
<li>尽量不要嵌套使用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">	/**</div><div class="line">	 * 哲学家们吃饭,一人只有一只筷子,都想说服别人把筷子给自己,然而谁也说不过谁,最后就被饿死了</div><div class="line">	 */</div><div class="line">	private static String s1 = &quot;筷子左&quot;;</div><div class="line">	private static String s2 = &quot;筷子右&quot;;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					synchronized(s1) &#123;</div><div class="line">						System.out.println(getName() + &quot;...获取&quot; + s1 + &quot;等待&quot; + s2);</div><div class="line">						synchronized(s2) &#123;</div><div class="line">							System.out.println(getName() + &quot;...拿到&quot; + s2 + &quot;开吃&quot;);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					synchronized(s2) &#123;</div><div class="line">						System.out.println(getName() + &quot;...获取&quot; + s2 + &quot;等待&quot; + s1);</div><div class="line">						synchronized(s1) &#123;</div><div class="line">							System.out.println(getName() + &quot;...拿到&quot; + s1 + &quot;开吃&quot;);</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>以上代码,会让程序锁死</li>
</ul>
<h3 id="以前的线程安全的类回顾"><a href="#以前的线程安全的类回顾" class="headerlink" title="以前的线程安全的类回顾"></a>以前的线程安全的类回顾</h3><ul>
<li>A:回顾的线程安全问题<ul>
<li>看源码：Vector,StringBuffer,Hashtable,Collections.synchroinzed(xxx)</li>
<li>Vector是线程安全的,ArrayList是线程不安全的</li>
<li>StringBuffer是线程安全的,StringBuilder是线程不安全的</li>
<li>Hashtable是线程安全的,HashMap是线程不安全的</li>
<li>Collections.synchroinzed(xxx) 可以把线程不安全的集合变成线程安全的</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

