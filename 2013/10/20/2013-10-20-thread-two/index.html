<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="wxhao">
  <!-- Open Graph Data -->
  <meta property="og:title" content="多线程2"/>
  <meta property="og:description" content="站点描述" />
  <meta property="og:site_name" content="标题"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://blog.wxhaoo.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="标题" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>标题</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">多线程2</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/levblanc">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:levblanc@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By wxhao</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2013-10-20</span>
            <span class="time">17:38:06</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/基础知识/">#基础知识</a> <a class="tag" href="/tags/java/">#java</a> <a class="tag" href="/tags/JAVASE/">#JAVASE</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><ul>
<li><p>单例设计模式：保证类在内存中只有一个对象。</p>
</li>
<li><p>如何保证类在内存中只有一个对象呢？</p>
<ul>
<li>(1)控制类的创建，不让其他类来创建本类的对象。private</li>
<li>(2)在本类中定义一个本类的对象。Singleton s;</li>
<li>(3)提供公共的访问方式。  public static Singleton getInstance(){return s}</li>
</ul>
</li>
<li>单例写法两种：</li>
<li>(1)饿汉式 开发用这种方式。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">	//1,私有构造方法,其他类不能访问该构造方法了</div><div class="line">	private Singleton()&#123;&#125;</div><div class="line">	//2,创建本类对象</div><div class="line">	private static Singleton s = new Singleton();</div><div class="line">	//3,对外提供公共的访问方法</div><div class="line">	public static Singleton getInstance() &#123;	//获取实例</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>(2)懒汉式 面试写这种方式。多线程的问题？</li>
<li>懒汉式,单例的延迟加载模式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">	//1,私有构造方法,其他类不能访问该构造方法了</div><div class="line">	private Singleton()&#123;&#125;</div><div class="line">	//2,声明一个引用</div><div class="line">	private static Singleton s ;</div><div class="line">	//3,对外提供公共的访问方法</div><div class="line">	public static Singleton getInstance() &#123;	//获取实例</div><div class="line">		if(s == null) &#123;</div><div class="line">			//线程1等待,线程2等待</div><div class="line">			s = new Singleton();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		return s;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>饿汉式和懒汉式的区别</p>
<ol>
<li>饿汉式是空间换时间,懒汉式是时间换空间</li>
<li>在多线程访问时,饿汉式不会创建多个对象,而懒汉式有可能会创建多个对象</li>
</ol>
</li>
<li><p>(3)第三种格式</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Singleton &#123;</div><div class="line">	//1,私有构造方法,其他类不能访问该构造方法了</div><div class="line">	private Singleton()&#123;&#125;</div><div class="line">	//2,声明一个引用</div><div class="line">	public static final Singleton s = new Singleton();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><ul>
<li>Runtime类是一个单例类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Runtime r = Runtime.getRuntime();</div><div class="line">//r.exec(&quot;shutdown -s -t 300&quot;);		//300秒后关机</div><div class="line">r.exec(&quot;shutdown -a&quot;);				//取消关机</div></pre></td></tr></table></figure>
<h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><ul>
<li>Timer类:计时器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class Demo3_Timer &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * @throws InterruptedException </div><div class="line">	 */</div><div class="line">	public static void main(String[] args) throws InterruptedException &#123;</div><div class="line">		Timer t = new Timer();</div><div class="line">		//在指定时间安排指定任务</div><div class="line">		//第一个参数,是安排的任务,第二个参数是执行的时间,第三个参数是过多长时间再重复执行</div><div class="line">		t.schedule(new MyTimerTask(), new Date(188, 6, 1, 14, 22, 50),3000);	</div><div class="line">		</div><div class="line">		while(true) &#123;</div><div class="line">			Thread.sleep(1000);</div><div class="line">			System.out.println(new Date());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class MyTimerTask extends TimerTask &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		System.out.println(&quot;起床背英语单词&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>传入时间查看API,实例为20880601142250</li>
</ul>
<h3 id="两个线程间的通信"><a href="#两个线程间的通信" class="headerlink" title="两个线程间的通信"></a>两个线程间的通信</h3><ul>
<li>1.什么时候需要通信<ul>
<li>多个线程并发执行时, 在默认情况下CPU是随机切换线程的</li>
<li>如果我们希望他们有规律的执行, 就可以使用通信, 例如每个线程执行一次打印</li>
</ul>
</li>
<li>2.怎么通信<ul>
<li>如果希望线程等待, 就调用wait()</li>
<li>如果希望唤醒等待的线程, 就调用notify();</li>
<li>这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">package com.wxhao.thread2;</div><div class="line"></div><div class="line">public class Demo1_Notify &#123;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 等待唤醒机制</div><div class="line">	 */</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Printer p = new Printer();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print1();</div><div class="line">					&#125; catch (InterruptedException e) &#123;					</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print2();</div><div class="line">					&#125; catch (InterruptedException e) &#123;						</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//等待唤醒机制</div><div class="line">class Printer &#123;</div><div class="line">	private int flag = 1;</div><div class="line">	public void print1() throws InterruptedException &#123;							</div><div class="line">		synchronized(this) &#123;</div><div class="line">			if(flag != 1) &#123;</div><div class="line">				this.wait();					//当前线程等待</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;我&quot;);</div><div class="line">			System.out.print(&quot;是&quot;);</div><div class="line">			System.out.print(&quot;大&quot;);</div><div class="line">			System.out.print(&quot;帅&quot;);</div><div class="line">			System.out.print(&quot;哔&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 2;</div><div class="line">			this.notify();		//随机唤醒单个等待的线程</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print2() throws InterruptedException &#123;</div><div class="line">		synchronized(this) &#123;</div><div class="line">			if(flag != 2) &#123;</div><div class="line">				this.wait();</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;吴&quot;);</div><div class="line">			System.out.print(&quot;酷&quot;);</div><div class="line">			System.out.print(&quot;浩&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 1;</div><div class="line">			this.notify();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="三个或三个以上间的线程通信"><a href="#三个或三个以上间的线程通信" class="headerlink" title="三个或三个以上间的线程通信"></a>三个或三个以上间的线程通信</h3><ul>
<li>多个线程通信的问题<ul>
<li>notify()方法是随机唤醒一个线程</li>
<li>notifyAll()方法是唤醒所有线程</li>
<li>JDK5之前无法唤醒指定的一个线程</li>
<li>如果多个线程之间通信, 需要使用notifyAll()通知所有线程, 用while来反复判断条件</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">package com.wxhao.thread2;</div><div class="line"></div><div class="line">public class Demo2_NotifyAll &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Printer2 p = new Printer2();</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print1();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print2();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print3();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Printer2 &#123;</div><div class="line">	private int flag = 1;</div><div class="line">	public void print1() throws InterruptedException &#123;							</div><div class="line">		synchronized(this) &#123;</div><div class="line">			while(flag != 1) &#123;</div><div class="line">				this.wait();	//当前线程等待</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;我&quot;);</div><div class="line">			System.out.print(&quot;是&quot;);</div><div class="line">			System.out.print(&quot;大&quot;);</div><div class="line">			System.out.print(&quot;帅&quot;);</div><div class="line">			System.out.print(&quot;哔&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 2;</div><div class="line">			//this.notify();	//随机唤醒单个等待的线程</div><div class="line">			this.notifyAll();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print2() throws InterruptedException &#123;</div><div class="line">		synchronized(this) &#123;</div><div class="line">			while(flag != 2) &#123;</div><div class="line">				this.wait();	//线程2在此等待</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;吴&quot;);</div><div class="line">			System.out.print(&quot;酷&quot;);</div><div class="line">			System.out.print(&quot;浩&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 3;</div><div class="line">			//this.notify();</div><div class="line">			this.notifyAll();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print3() throws InterruptedException &#123;</div><div class="line">		synchronized(this) &#123;</div><div class="line">			while(flag != 3) &#123;</div><div class="line">				this.wait();	//线程3在此等待,if语句是在哪里等待,就在哪里起来</div><div class="line">								//while循环是循环判断,每次都会判断标记</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;刘&quot;);</div><div class="line">			System.out.print(&quot;二&quot;);</div><div class="line">			System.out.print(&quot;圆&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 1;</div><div class="line">			//this.notify();</div><div class="line">			this.notifyAll();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>1,在同步代码块中,用哪个对象锁,就用哪个对象调用wait方法</li>
<li>2,为什么wait方法和notify方法定义在Object这类中?<ul>
<li>因为锁对象可以是任意对象,Object是所有的类的基类,所以wait方法和notify方法需要定义在Object这个类中</li>
</ul>
</li>
<li>3,sleep方法和wait方法的区别?<ul>
<li>sleep方法必须传入参数,参数就是时间,时间到了自动醒来<br>wait方法可以传入参数也可以不传入参数,传入参数就是在参数的时间结束后等待,不传入参数就是直接等待</li>
<li>sleep方法在同步函数或同步代码块中,不释放锁,睡着了也抱着锁睡<br>wait方法在同步函数或者同步代码块中,释放锁</li>
</ul>
</li>
</ul>
<h3 id="JDK1-5的新特性互斥锁"><a href="#JDK1-5的新特性互斥锁" class="headerlink" title="JDK1.5的新特性互斥锁"></a>JDK1.5的新特性互斥锁</h3><ul>
<li>1.同步<ul>
<li>使用ReentrantLock类的lock()和unlock()方法进行同步</li>
</ul>
</li>
<li>2.通信<ul>
<li>使用ReentrantLock类的newCondition()方法可以获取Condition对象</li>
<li>需要等待的时候使用Condition的await()方法, 唤醒的时候用signal()方法</li>
<li>不同的线程使用不同的Condition, 这样就能区分唤醒的时候找哪个线程了</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">package com.wxhao.thread2;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Condition;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">public class Demo3_ReentrantLock &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		final Printer3 p = new Printer3();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print1();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print2();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">		</div><div class="line">		new Thread() &#123;</div><div class="line">			public void run() &#123;</div><div class="line">				while(true) &#123;</div><div class="line">					try &#123;</div><div class="line">						p.print3();</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;.start();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Printer3 &#123;</div><div class="line">	private ReentrantLock r = new ReentrantLock();</div><div class="line">	private Condition c1 = r.newCondition();</div><div class="line">	private Condition c2 = r.newCondition();</div><div class="line">	private Condition c3 = r.newCondition();</div><div class="line">	</div><div class="line">	private int flag = 1;</div><div class="line">	public void print1() throws InterruptedException &#123;							</div><div class="line">		r.lock();				//获取锁</div><div class="line">			if(flag != 1) &#123;</div><div class="line">				c1.await();</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;我&quot;);</div><div class="line">			System.out.print(&quot;是&quot;);</div><div class="line">			System.out.print(&quot;大&quot;);</div><div class="line">			System.out.print(&quot;帅&quot;);</div><div class="line">			System.out.print(&quot;哔&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 2;</div><div class="line">			//this.notify();	//随机唤醒单个等待的线程</div><div class="line">			c2.signal();</div><div class="line">		r.unlock();				//释放锁</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print2() throws InterruptedException &#123;</div><div class="line">		r.lock();</div><div class="line">			if(flag != 2) &#123;</div><div class="line">				c2.await();</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;吴&quot;);</div><div class="line">			System.out.print(&quot;酷&quot;);</div><div class="line">			System.out.print(&quot;浩&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 3;</div><div class="line">			//this.notify();</div><div class="line">			c3.signal();</div><div class="line">		r.unlock();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void print3() throws InterruptedException &#123;</div><div class="line">		r.lock();</div><div class="line">			if(flag != 3) &#123;</div><div class="line">				c3.await();</div><div class="line">			&#125;</div><div class="line">			System.out.print(&quot;刘&quot;);</div><div class="line">			System.out.print(&quot;二&quot;);</div><div class="line">			System.out.print(&quot;圆&quot;);</div><div class="line">			System.out.print(&quot;\r\n&quot;);</div><div class="line">			flag = 1;</div><div class="line">			c1.signal();</div><div class="line">		r.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="线程组的概述和使用"><a href="#线程组的概述和使用" class="headerlink" title="线程组的概述和使用"></a>线程组的概述和使用</h3><ul>
<li>A:线程组概述<ul>
<li>Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。</li>
<li>默认情况下，所有的线程都属于主线程组。<ul>
<li>public final ThreadGroup getThreadGroup()//通过线程对象获取他所属于的组</li>
<li>public final String getName()//通过线程组对象获取他组的名字</li>
</ul>
</li>
<li>我们也可以给线程设置分组<ul>
<li>1,ThreadGroup(String name) 创建线程组对象并给其赋值名字</li>
<li>2,创建线程对象</li>
<li>3,Thread(ThreadGroup?group, Runnable?target, String?name) </li>
<li>4,设置整组的优先级或者守护线程</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>线程组的使用,默认是主线程组</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">MyRunnable mr = new MyRunnable();</div><div class="line">Thread t1 = new Thread(mr, &quot;张三&quot;);</div><div class="line">Thread t2 = new Thread(mr, &quot;李四&quot;);</div><div class="line">//获取线程组</div><div class="line">// 线程类里面的方法：public final ThreadGroup getThreadGroup()</div><div class="line">ThreadGroup tg1 = t1.getThreadGroup();</div><div class="line">ThreadGroup tg2 = t2.getThreadGroup();</div><div class="line">// 线程组里面的方法：public final String getName()</div><div class="line">String name1 = tg1.getName();</div><div class="line">String name2 = tg2.getName();</div><div class="line">System.out.println(name1);</div><div class="line">System.out.println(name2);</div><div class="line">// 通过结果我们知道了：线程默认情况下属于main线程组</div><div class="line">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</div><div class="line">System.out.println(Thread.currentThread().getThreadGroup().getName());</div></pre></td></tr></table></figure>
<ul>
<li>自己设定线程组</li>
</ul>
<p>｀｀｀<br>// ThreadGroup(String name)<br>ThreadGroup tg = new ThreadGroup(“这是一个新的组”);</p>
<p>MyRunnable mr = new MyRunnable();<br>// Thread(ThreadGroup group, Runnable target, String name)<br>Thread t1 = new Thread(tg, mr, “张三”);<br>Thread t2 = new Thread(tg, mr, “李四”);</p>
<p>System.out.println(t1.getThreadGroup().getName());<br>System.out.println(t2.getThreadGroup().getName());</p>
<p>//通过组名称设置后台线程，表示该组的线程都是后台线程<br>tg.setDaemon(true);<br>｀｀｀        </p>
<h3 id="线程的五种状态"><a href="#线程的五种状态" class="headerlink" title="线程的五种状态　"></a>线程的五种状态　</h3><ul>
<li>看图说话</li>
<li>新建,就绪,运行,阻塞,死亡</li>
</ul>
<p><img src="!--￼16--&gt;/post-in/20131020/xcztt.png" alt="线程状态图"></p>
<h3 id="线程池的概述和使用"><a href="#线程池的概述和使用" class="headerlink" title="线程池的概述和使用"></a>线程池的概述和使用</h3><ul>
<li>A:线程池概述<ul>
<li>程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</li>
</ul>
</li>
<li>B:内置线程池的使用概述<ul>
<li>JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法<ul>
<li>public static ExecutorService newFixedThreadPool(int nThreads)</li>
<li>public static ExecutorService newSingleThreadExecutor()</li>
<li>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。它提供了如下方法</li>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><t> Future<t> submit(Callable<t> task)</t></t></t></li>
</ul>
</li>
<li>使用步骤：<ul>
<li>创建线程池对象</li>
<li>创建Runnable实例</li>
<li>提交Runnable实例</li>
<li>关闭线程池</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>提交的是Runnable</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// public static ExecutorService newFixedThreadPool(int nThreads)</div><div class="line">ExecutorService pool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">// 可以执行Runnable对象或者Callable对象代表的线程</div><div class="line">pool.submit(new MyRunnable());</div><div class="line">pool.submit(new MyRunnable());</div><div class="line"></div><div class="line">//结束线程池</div><div class="line">pool.shutdown();</div></pre></td></tr></table></figure>
<h3 id="多线程程序实现的方式3"><a href="#多线程程序实现的方式3" class="headerlink" title="多线程程序实现的方式3"></a>多线程程序实现的方式3</h3><ul>
<li>提交的是Callable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 创建线程池对象</div><div class="line">ExecutorService pool = Executors.newFixedThreadPool(2);</div><div class="line"></div><div class="line">// 可以执行Runnable对象或者Callable对象代表的线程</div><div class="line">Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));</div><div class="line">Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));</div><div class="line"></div><div class="line">// V get()</div><div class="line">Integer i1 = f1.get();</div><div class="line">Integer i2 = f2.get();</div><div class="line"></div><div class="line">System.out.println(i1);</div><div class="line">System.out.println(i2);</div><div class="line"></div><div class="line">// 结束</div><div class="line">pool.shutdown();</div><div class="line"></div><div class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</div><div class="line"></div><div class="line">	private int number;</div><div class="line"></div><div class="line">	public MyCallable(int number) &#123;</div><div class="line">		this.number = number;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public Integer call() throws Exception &#123;</div><div class="line">		int sum = 0;</div><div class="line">		for (int x = 1; x &lt;= number; x++) &#123;</div><div class="line">			sum += x;</div><div class="line">		&#125;</div><div class="line">		return sum;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>多线程程序实现的方式3的好处和弊端<ul>
<li>好处：<ul>
<li>可以有返回值</li>
<li>可以抛出异常</li>
</ul>
</li>
<li>弊端：<ul>
<li>代码比较复杂，所以一般不用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>25.11_设计模式(</p>
<h3 id="简单工厂模式概述和使用"><a href="#简单工厂模式概述和使用" class="headerlink" title="简单工厂模式概述和使用"></a>简单工厂模式概述和使用</h3><ul>
<li>A:简单工厂模式概述<ul>
<li>又叫静态工厂方法模式，它定义一个具体的工厂类负责创建一些类的实例</li>
</ul>
</li>
<li>B:优点<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责</li>
</ul>
</li>
<li>C:缺点<ul>
<li>这个静态工厂类负责所有对象的创建，如果有新的对象增加，或者某些对象的创建方式不同，就需要不断的修改工厂类，不利于后期的维护</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>动物抽象类：public abstract Animal { public abstract void eat(); }</li>
<li>具体狗类：public class Dog extends Animal {}</li>
<li>具体猫类：public class Cat extends Animal {}</li>
<li>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class AnimalFactory &#123;</div><div class="line">	private AnimalFactory()&#123;&#125;</div><div class="line"></div><div class="line">	//public static Dog createDog() &#123;return new Dog();&#125;</div><div class="line">	//public static Cat createCat() &#123;return new Cat();&#125;</div><div class="line"></div><div class="line">	//改进</div><div class="line">	public static Animal createAnimal(String animalName) &#123;</div><div class="line">		if(“dog”.equals(animalName)) &#123;&#125;</div><div class="line">		else if(“cat”.equals(animale)) &#123;</div><div class="line"></div><div class="line">		&#125;else &#123;</div><div class="line">			return null;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125; </div><div class="line">```		</div><div class="line"></div><div class="line">### 工厂方法模式的概述和使用 </div><div class="line">* A:工厂方法模式概述</div><div class="line">	* 工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</div><div class="line">* B:优点</div><div class="line">	* 客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</div><div class="line">* C:缺点</div><div class="line">	* 需要额外的编写代码，增加了工作量</div><div class="line">* D:案例演示</div></pre></td></tr></table></figure>
<p>动物抽象类：public abstract Animal { public abstract void eat(); }<br>工厂接口：public interface Factory {public abstract Animal createAnimal();}<br>具体狗类：public class Dog extends Animal {}<br>具体猫类：public class Cat extends Animal {}<br>开始，在测试类中每个具体的内容自己创建对象，但是，创建对象的工作如果比较麻烦，就需要有人专门做这个事情，所以就知道了一个专门的类来创建对象。发现每次修改代码太麻烦，用工厂方法改进，针对每一个具体的实现提供一个具体工厂。<br>狗工厂：public class DogFactory implements Factory {<br>    public Animal createAnimal() {…}<br>        }<br>猫工厂：public class CatFactory implements Factory {<br>    public Animal createAnimal() {…}<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">25.13_GUI(</div><div class="line"></div><div class="line">### 如何创建一个窗口并显示 </div><div class="line">* Graphical User Interface(图形用户接口)。</div></pre></td></tr></table></figure></p>
<p>Frame  f = new Frame(“my window”);<br>f.setLayout(new FlowLayout());//设置布局管理器<br>f.setSize(500,400);//设置窗体大小<br>f.setLocation(300,200);//设置窗体出现在屏幕的位置<br>f.setIconImage(Toolkit.getDefaultToolkit().createImage(“qq.png”));<br>f.setVisible(true);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###  布局管理器 </div><div class="line">* FlowLayout（流式布局管理器）</div><div class="line">	* 从左到右的顺序排列。</div><div class="line">	* Panel默认的布局管理器。</div><div class="line">* BorderLayout（边界布局管理器）</div><div class="line">	* 东，南，西，北，中</div><div class="line">	* Frame默认的布局管理器。</div><div class="line">* GridLayout（网格布局管理器）</div><div class="line">	* 规则的矩阵</div><div class="line">* CardLayout（卡片布局管理器）</div><div class="line">	* 选项卡</div><div class="line">* GridBagLayout（网格包布局管理器）</div><div class="line">	* 非规则的矩阵</div><div class="line"></div><div class="line">### 窗体监听</div></pre></td></tr></table></figure></p>
<p>Frame f = new Frame(“我的窗体”);<br>//事件源是窗体,把监听器注册到事件源上<br>//事件对象传递给监听器<br>f.addWindowListener(new WindowAdapter() {<br>          public void windowClosing(WindowEvent e) {<br>                     //退出虚拟机,关闭窗口<br>        System.exit(0);<br>    }<br>});<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* 鼠标监听 addMouseListener</div><div class="line">* 键盘监听和键盘事件 addKeyListener</div><div class="line">* 动作监听 addActionListener 绑定空格和鼠标单左键</div></pre></td></tr></table></figure></p>
<p>package com.wxhao.gui;</p>
<p>import java.awt.Button;<br>import java.awt.FlowLayout;<br>import java.awt.Frame;<br>import java.awt.Toolkit;<br>import java.awt.event.ActionEvent;<br>import java.awt.event.ActionListener;<br>import java.awt.event.KeyAdapter;<br>import java.awt.event.KeyEvent;<br>import java.awt.event.MouseAdapter;<br>import java.awt.event.MouseEvent;<br>import java.awt.event.WindowAdapter;<br>import java.awt.event.WindowEvent;<br>import java.awt.event.WindowListener;</p>
<p>public class Demo1_Frame {</p>
<pre><code>public static void main(String[] args) {
    Frame f = new Frame(&quot;我的第一个窗口&quot;);
    f.setSize(400, 600);                            //设置窗体大小
    f.setLocation(500, 50);                            //设置窗体位置
    f.setIconImage(Toolkit.getDefaultToolkit().createImage(&quot;qq.png&quot;));
    Button b1 = new Button(&quot;按钮一&quot;);
    Button b2 = new Button(&quot;按钮二&quot;);
    f.add(b1);
    f.add(b2);
    f.setLayout(new FlowLayout());        //设置布局管理器
    //f.addWindowListener(new MyWindowAdapter());
    //窗口监听
    f.addWindowListener(new WindowAdapter() {
        @Override
        public void windowClosing(WindowEvent e) {
            System.exit(0);
        }
    });
    //鼠标监听
    b1.addMouseListener(new MouseAdapter() {
        /*@Override
        public void mouseClicked(MouseEvent e) {    //单击
            System.exit(0);
        }*/
        @Override
        public void mouseReleased(MouseEvent e) {    //释放
            System.exit(0);
        }
    });
    //键盘监听
    b1.addKeyListener(new KeyAdapter() {
        @Override
        public void keyReleased(KeyEvent e) {
            //System.exit(0);
            //System.out.println(e.getKeyCode());
            //if(e.getKeyCode() == 32) {
            if(e.getKeyCode() == KeyEvent.VK_SPACE){
                System.exit(0);
            }
        }
    });
    //添加动作监听,应用场景就是暂停视频和播放视频
    b2.addActionListener(new ActionListener() {        
        @Override
        public void actionPerformed(ActionEvent e) {
            System.exit(0);
        }
    });
    f.setVisible(true);            //设置窗体可见
}
</code></pre><p>}</p>
<p>/*class MyWindowListener implements WindowListener {</p>
<pre><code>@Override
public void windowOpened(WindowEvent e) {
}
@Override
public void windowClosing(WindowEvent e) {
    System.exit(0);
}
@Override
public void windowClosed(WindowEvent e) {
    System.out.println(&quot;Closed&quot;);
}
@Override
public void windowIconified(WindowEvent e) {
}
@Override
public void windowDeiconified(WindowEvent e) {
}
@Override
public void windowActivated(WindowEvent e) {
}
@Override
public void windowDeactivated(WindowEvent e) {
}
</code></pre><p>}<br>*/</p>
<p>/<em>class MyWindowAdapter extends WindowAdapter {<br>    @Override<br>    public void windowClosing(WindowEvent e) {<br>        System.exit(0);<br>    }<br>}</em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">25.19_设计模式(</div><div class="line"></div><div class="line">### 适配器设计模式 </div><div class="line">* a.什么是适配器</div><div class="line">	* 在使用监听器的时候, 需要定义一个类事件监听器接口.</div><div class="line">	* 通常接口中有多个方法, 而程序中不一定所有的都用到, 但又必须重写, 这很繁琐.</div><div class="line">	* 适配器简化了这些操作, 我们定义监听器时只要继承适配器, 然后重写需要的方法即可.</div><div class="line">* b.适配器原理</div><div class="line">	* 适配器就是一个类, 实现了监听器接口, 所有抽象方法都重写了, 但是方法全是空的.</div><div class="line">	* 适配器类需要定义成抽象的,因为创建该类对象,调用空方法是没有意义的</div><div class="line">	* 目的就是为了简化程序员的操作, 定义监听器时继承适配器, 只重写需要的方法就可以了.</div></pre></td></tr></table></figure></p>
<p>interface 和尚 {<br>    public void 打坐();<br>    public void 念经();<br>    public void 撞钟();<br>    public void 习武();<br>}</p>
<p>//声明成抽象的原因是,不想让其他类创建本类对象,因为创建也没有意义,方法都是空的<br>abstract class 天罡星 implements 和尚 {<br>    @Override<br>    public void 打坐() {}<br>    @Override<br>    public void 念经() {}<br>    @Override<br>    public void 撞钟() {}<br>    @Override<br>    public void 习武() {}<br>}</p>
<p>class 鲁智深 extends 天罡星 {<br>    public void 习武() {<br>        System.out.println(“倒拔垂杨柳”);<br>        System.out.println(“拳打镇关西”);<br>        System.out.println(“大闹野猪林”);<br>        System.out.println(“……”);<br>    }<br>}<br>```</p>
<h3 id="GUI-需要知道的"><a href="#GUI-需要知道的" class="headerlink" title="GUI(需要知道的)"></a>GUI(需要知道的)</h3><ul>
<li>事件处理<ul>
<li>事件: 用户的一个操作</li>
<li>事件源: 被操作的组件</li>
<li>监听器: 一个自定义类的对象, 实现了监听器接口, 包含事件处理方法,把监听器添加在事件源上, 当事件发生的时候虚拟机就会自动调用监听器中的事件处理方法</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

