<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="wxhao">
  <!-- Open Graph Data -->
  <meta property="og:title" content="IO流3"/>
  <meta property="og:description" content="站点描述" />
  <meta property="og:site_name" content="标题"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://blog.wxhaoo.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="标题" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>标题</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-dark.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">IO流3</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/levblanc">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="mailto:levblanc@163.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By wxhao</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2013-09-30</span>
            <span class="time">17:38:06</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/基础知识/">#基础知识</a> <a class="tag" href="/tags/java/">#java</a> <a class="tag" href="/tags/JAVASE/">#JAVASE</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h3 id="序列流"><a href="#序列流" class="headerlink" title="序列流"></a>序列流</h3><ul>
<li>1.什么是序列流<ul>
<li>序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推.</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>整合两个: SequenceInputStream(InputStream, InputStream)</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;);			//创建输入流对象,关联a.txt</div><div class="line">FileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;);			//创建输入流对象,关联b.txt</div><div class="line">SequenceInputStream sis = new SequenceInputStream(fis1, fis2);	//将两个流整合成一个流</div><div class="line">FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;);			//创建输出流对象,关联c.txt</div><div class="line"></div><div class="line">int b;</div><div class="line">while((b = sis.read()) != -1) &#123;									//用整合后的读</div><div class="line">	fos.write(b);												//写到指定文件上</div><div class="line">&#125;</div><div class="line">//sis在关闭的时候,会将构造方法中传入的流对象也都关闭</div><div class="line">sis.close();</div><div class="line">fos.close();</div></pre></td></tr></table></figure>
<ul>
<li>为什么要用序列流整合?<ul>
<li>因为两个读取多个流复用性太差</li>
</ul>
</li>
</ul>
<h3 id="序列流整合多个"><a href="#序列流整合多个" class="headerlink" title="序列流整合多个"></a>序列流整合多个</h3><ul>
<li>整合多个: SequenceInputStream(Enumeration)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;);	//创建输入流对象,关联a.txt</div><div class="line">FileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;);	//创建输入流对象,关联b.txt</div><div class="line">FileInputStream fis3 = new FileInputStream(&quot;c.txt&quot;);	//创建输入流对象,关联c.txt</div><div class="line">Vector&lt;InputStream&gt; v = new Vector&lt;&gt;();					//创建vector集合对象</div><div class="line">v.add(fis1);											//将流对象添加</div><div class="line">v.add(fis2);</div><div class="line">v.add(fis3);</div><div class="line">Enumeration&lt;InputStream&gt; en = v.elements();				//获取枚举引用</div><div class="line">SequenceInputStream sis = new SequenceInputStream(en);	//传递给SequenceInputStream构造</div><div class="line">FileOutputStream fos = new FileOutputStream(&quot;d.txt&quot;);</div><div class="line">int b;</div><div class="line">while((b = sis.read()) != -1) &#123;</div><div class="line">	fos.write(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sis.close();</div><div class="line">fos.close();</div></pre></td></tr></table></figure>
<h3 id="内存输出流"><a href="#内存输出流" class="headerlink" title="内存输出流"></a>内存输出流</h3><ul>
<li>1.什么是内存输出流<ul>
<li>该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据</li>
</ul>
</li>
<li>2.使用方式<ul>
<li>创建对象: new ByteArrayOutputStream()</li>
<li>写出数据: write(int), write(byte[])</li>
<li>获取数据: toByteArray()</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);</div><div class="line">ByteArrayOutputStream baos = new ByteArrayOutputStream(); //在内存中创建了可以增长的内存数组</div><div class="line">int b;</div><div class="line">while((b = fis.read()) != -1) &#123;</div><div class="line">	baos.write(b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//byte[] newArr = baos.toByteArray();				//将内存缓冲区中所有的字节存储在newArr中</div><div class="line">//System.out.println(new String(newArr));</div><div class="line"></div><div class="line">//byte[] arr = baos.toByteArray();			//将缓冲区的数据全部获取出来,并赋值给arr数组</div><div class="line">//System.out.println(new String(arr));</div><div class="line">System.out.println(baos); //将缓冲区的内容转换为了字符串,在输出语句中可以省略调用toString方法</div><div class="line">fis.close();</div><div class="line">```			</div><div class="line"></div><div class="line">* FileInputStream读取中文的时候出现了乱码</div><div class="line">	 * 解决方案</div><div class="line">	    1. 字符流读取</div><div class="line">	    2. ByteArrayOutputStream</div><div class="line"></div><div class="line">	</div><div class="line">### 内存输出流之黑马面试题 </div><div class="line">* 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5)</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>分析:</li>
<li>1,read(byte[] b)是字节输入流的方法,创建FileInputStream,关联a.txt</li>
<li>2,创建内存输出流,将读到的数据写到内存输出流中</li>
<li>3,创建字节数组,长度为5</li>
<li>4,将内存输出流的数据全部转换为字符串打印</li>
<li>5,关闭输入流</li>
<li><p>@throws IOException<br>*/<br>public static void main(String[] args) throws IOException {<br> //1,reda(byte[] b)是字节输入流的方法,创建FileInputStream,关联a.txt<br> FileInputStream fis = new FileInputStream(“a.txt”);<br> //2,创建内存输出流,将读到的数据写到内存输出流中<br> ByteArrayOutputStream baos = new ByteArrayOutputStream();<br> //3,创建字节数组,长度为5<br> byte[] arr = new byte[5];<br> int len;</p>
<p> while((len = fis.read(arr)) != -1) {</p>
<pre><code>baos.write(arr, 0, len);
//System.out.println(new String(arr,0,len));
</code></pre><p> }<br> //4,将内存输出流的数据全部转换为字符串打印<br> System.out.println(baos); //即使没有调用,底层也会默认帮我们调用toString()方法<br> //5,关闭输入流<br> fis.close();<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">### 对象操作流ObjecOutputStream </div><div class="line">* 1.什么是对象操作流</div><div class="line">	* 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作.</div><div class="line">* 2.使用方式</div><div class="line">	* 写出: new ObjectOutputStream(OutputStream), writeObject()</div><div class="line"></div><div class="line">* 序列化:将对象写到文件上</div></pre></td></tr></table></figure>
</li>
</ul>
<p>public class Demo3_ObjectOutputStream {</p>
<pre><code>/**
 * @param args
 * @throws IOException 
 * 将对象写出,序列化
 */
public static void main(String[] args) throws IOException {
    Person p1 = new Person(&quot;张三&quot;, 23);
    Person p2 = new Person(&quot;李四&quot;, 24);
</code></pre><p>//        FileOutputStream fos = new FileOutputStream(“e.txt”);<br>//        fos.write(p1);<br>//        FileWriter fw = new FileWriter(“e.txt”);<br>//        fw.write(p1);<br>        //无论是字节输出流,还是字符输出流都不能直接写出对象<br>        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“e.txt”));//创建对象输出流<br>        oos.writeObject(p1);<br>        oos.writeObject(p2);<br>        oos.close();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### 对象操作流ObjectInputStream </div><div class="line">* 读取: new ObjectInputStream(InputStream), readObject()</div></pre></td></tr></table></figure></p>
<p>public class Demo3_ObjectInputStream {<br>    /**</p>
<pre><code> * @param args
 * @throws IOException 
 * @throws ClassNotFoundException 
 * @throws FileNotFoundException 
 * 读取对象,反序列化
 */
public static void main(String[] args) throws IOException, ClassNotFoundException {
    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e.txt&quot;));
    Person p1 = (Person) ois.readObject();
    Person p2 = (Person) ois.readObject();
    //Person p3 = (Person) ois.readObject();
    //当文件读取到了末尾时出现EOFException
    System.out.println(p1);
    System.out.println(p2);
    ois.close();
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 对象操作流优化 </div><div class="line">*　将对象存储在集合中写出</div></pre></td></tr></table></figure></p>
<p>Person p1 = new Person(“张三”, 23);<br>Person p2 = new Person(“李四”, 24);<br>Person p3 = new Person(“马哥”, 18);<br>Person p4 = new Person(“辉哥”, 20);</p>
<p>ArrayList<person> list = new ArrayList&lt;&gt;();<br>list.add(p1);<br>list.add(p2);<br>list.add(p3);<br>list.add(p4);</person></p>
<p>ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(“f.txt”));<br>oos.writeObject(list);//写出集合对象</p>
<p>oos.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 读取到的是一个集合对象</div></pre></td></tr></table></figure></p>
<p>ObjectInputStream ois = new ObjectInputStream(new FileInputStream(“f.txt”));<br>    ArrayList<person> list = (ArrayList<person>)ois.readObject();    //泛型在运行期会被擦除,索引运行期相当于没有泛型<br>                                                                    //想去掉黄色可以加注解                    @SuppressWarnings(“unchecked”)<br>    for (Person person : list) {<br>        System.out.println(person);<br>    }</person></person></p>
<p>ois.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 加上id号 </div><div class="line">* 注意</div><div class="line">	* 要写出的对象必须实现Serializable接口才能被序列化</div><div class="line">	* 不用必须加id号</div></pre></td></tr></table></figure></p>
<p>public class Person implements Serializable {<br>    /**</p>
<pre><code> * 
 */
private static final long serialVersionUID = 2L;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 打印流的概述和特点 </div><div class="line">* 1.什么是打印流</div><div class="line">	* 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式</div><div class="line">	* System.out就是一个PrintStream, 其默认向控制台输出信息</div></pre></td></tr></table></figure></p>
<p>PrintStream ps = System.out;<br>ps.println(97);                            //底层通过Integer.toString()将97转换成字符串并打印<br>ps.write(97);                            //查找码表,找到对应的a并打印<br>ps.println(“xxx”);<br>ps.println(new Person(“张三”, 23));<br>Person p = null;<br>ps.println(p);                    //如果是null,就返回null,如果不是null,就调用对象的toString()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 2.使用方式</div><div class="line">	* 打印: print(), println()</div><div class="line">	* 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) </div><div class="line">	* 打印流只操作数据目的</div></pre></td></tr></table></figure></p>
<p>PrintWriter pw = new PrintWriter(new FileOutputStream(“g.txt”), true);<br>pw.write(97);<br>pw.print(“大家好”);<br>pw.println(“你好”);                //自动刷出,只针对的是println方法<br>pw.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* PrintStream和PrintWriter分别是打印的字节流和字符流</div><div class="line">* 只操作数据目的的</div><div class="line"></div><div class="line"></div><div class="line">### 标准输入输出流概述和输出语句 </div><div class="line">* 1.什么是标准输入输出流(掌握)</div><div class="line">	* System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据</div><div class="line">	* System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据</div></pre></td></tr></table></figure></p>
<p>InputStream is = System.in;<br>int x = is.read();<br>System.out.println(x);</p>
<p>is.close();//不用关流,因为没有指向文件</p>
<p>InputStream is2 = System.in;//之前关了,就没开了<br>int y = is2.read();<br>System.out.println(y);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 2.修改标准输入输出流(了解)</div><div class="line">	* 修改输入流: System.setIn(InputStream)</div><div class="line">	* 修改输出流: System.setOut(PrintStream)</div></pre></td></tr></table></figure></p>
<p>System.setIn(new FileInputStream(“a.txt”));    //改变标准输入流<br>System.setOut(new PrintStream(“b.txt”));    //改变标注输出流</p>
<p>InputStream is = System.in;        //获取标准的键盘输入流,默认指向键盘,改变后指向文件<br>PrintStream ps = System.out;    //获取标准输出流,默认指向的是控制台,改变后就指向文件</p>
<p>int b;<br>while((b = is.read()) != -1) {<br>    ps.write(b);<br>}<br>//System.out.println();        //也是一个输出流,不用关,因为没有和硬盘上的文件产生关联的管道<br>is.close();<br>ps.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 修改标准输入输出流拷贝图片</div></pre></td></tr></table></figure></p>
<p>System.setIn(new FileInputStream(“IO图片.png”));        //改变标准输入流<br>System.setOut(new PrintStream(“copy.png”)); //改变标准输出流<br>InputStream is = System.in;     //获取标准输入流<br>PrintStream ps = System.out; //获取标准输出流<br>int len;<br>byte[] arr = new byte[1024 * 8];</p>
<p>while((len = is.read(arr)) != -1) {<br>    ps.write(arr, 0, len);<br>}</p>
<p>is.close();<br>ps.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">###22.11_IO流(两种方式实现键盘录入)(了解)</div><div class="line">* A:BufferedReader的readLine方法。</div><div class="line">	* BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</div><div class="line">* B:Scanner</div></pre></td></tr></table></figure></p>
<p>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    //InputStreamReader转换流<br>String line = br.readLine();<br>System.out.println(line);<br>br.close();</p>
<p>Scanner sc = new Scanner(System.in);<br>String line2 = sc.nextLine();<br>System.out.println(line2);<br>sc.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 随机访问流概述和读写数据 </div><div class="line">* A:随机访问流概述</div><div class="line">	* RandomAccessFile概述</div><div class="line">	* RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。</div><div class="line">	* 支持对随机访问文件的读取和写入。</div><div class="line"></div><div class="line">* B:read(),write(),seek()</div></pre></td></tr></table></figure></p>
<p>RandomAccessFile raf = new RandomAccessFile(“g.txt”, “rw”);<br>//raf.write(97);<br>//int x = raf.read();<br>//System.out.println(x);<br>raf.seek(0);                    //在指定位置设置指针<br>raf.write(98);<br>raf.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 数据输入输出流 </div><div class="line">* 1.什么是数据输入输出流</div><div class="line">	* DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据</div><div class="line">	* 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节.</div></pre></td></tr></table></figure></p>
<p>/* 00000000 00000000 00000011 11100101    int类型997</p>
<ul>
<li>11100101</li>
<li>00000000 00000000 00000000 11100101<br>*/<br>FileOutputStream fos = new FileOutputStream(“h.txt”);<br>fos.write(997);<br>fos.write(998);<br>fos.write(999);</li>
</ul>
<p>fos.close();</p>
<p>FileInputStream fis = new FileInputStream(“h.txt”);<br>int x = fis.read();<br>int y = fis.read();<br>int z = fis.read();</p>
<p>System.out.println(x);//229<br>System.out.println(y);//230<br>System.out.println(z);//231</p>
<p>fis.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* 2.使用方式</div><div class="line">	* DataOutputStream(OutputStream), writeInt(), writeLong()</div></pre></td></tr></table></figure></p>
<p>DataOutputStream dos = new DataOutputStream(new FileOutputStream(“b.txt”));<br>dos.writeInt(997);<br>dos.writeInt(998);<br>dos.writeInt(999);</p>
<p>dos.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* DataInputStream(InputStream), readInt(), readLong()</div></pre></td></tr></table></figure></p>
<p>DataInputStream dis = new DataInputStream(new FileInputStream(“b.txt”));<br>int x = dis.readInt();<br>int y = dis.readInt();<br>int z = dis.readInt();<br>System.out.println(x);<br>System.out.println(y);<br>System.out.println(z);<br>dis.close();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Properties的概述和作为Map集合的使用 </div><div class="line">* A:Properties的概述</div><div class="line">	* Properties 类表示了一个持久的属性集。</div><div class="line">	* Properties 可保存在流中或从流中加载。</div><div class="line">	* 属性列表中每个键及其对应值都是一个字符串。 </div><div class="line">* B:案例演示</div><div class="line">	* Properties作为Map集合的使用</div></pre></td></tr></table></figure></p>
<p>Properties prop = new Properties();<br>prop.put(“abc”, 123);<br>System.out.println(prop);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">### Properties的特殊功能使用 </div><div class="line">* A:Properties的特殊功能</div><div class="line">	* public Object setProperty(String key,String value)</div><div class="line">	* public String getProperty(String key)</div><div class="line">	* public Enumeration&lt;String&gt; stringPropertyNames()</div><div class="line">* B:案例演示</div><div class="line">	* Properties的特殊功能</div></pre></td></tr></table></figure></p>
<p>Properties prop = new Properties();<br>prop.setProperty(“name”, “张三”);<br>prop.setProperty(“tel”, “18912345678”);</p>
<p>//System.out.println(prop);<br>Enumeration<string> en = (Enumeration<string>) prop.propertyNames();<br>while(en.hasMoreElements()) {<br>    String key = en.nextElement();                //获取Properties中的每一个键<br>    String value = prop.getProperty(key);        //根据键获取值<br>    System.out.println(key + “=”+ value);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">### Properties的load()和store()功能 )</div><div class="line">* A:Properties的load()和store()功能</div><div class="line">* B:案例演示</div><div class="line">	* Properties的load()和store()功能</div></pre></td></tr></table></figure></string></string></p>
<p>Properties prop = new Properties();<br>prop.load(new FileInputStream(“config.properties”));        //将文件上的键值对读取到集合中<br>prop.setProperty(“tel”, “18912345678”);<br>prop.store(new FileOutputStream(“config.properties”), null);//第二个参数是对列表参数的描述,可以给值,也可以给null<br>System.out.println(prop);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">* config.properties</div></pre></td></tr></table></figure></p>
<p>#Tue Jun 29 05:34:44 CST 2088<br>qq=12345<br>tel=18912345678<br>username=zhangsan<br>```</p>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

